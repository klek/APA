
void charToInt(char temp[], short int *xCoord, short int *yCoord)
{
	int i;
	for(i = 0; i < COMMANDSIZE; i++)
	{
		if ((temp[i] < 58) && (temp[i] > 47))
		{
			temp[i] = temp[i]-48;
		}
		else
		{
			// Error message?
		}
	}

	// Decode the message coordinates to ints
	*xCoord = 100*temp[0]+10*temp[1]+temp[2];
	*yCoord = 100*temp[3]+10*temp[4]+temp[5];

	// Scale millimeters to steps of the motors
	*xCoord = (*xCoord)*SCALE;
	*yCoord = (*yCoord)*SCALE;
}

------------------------------------------------------------------
// Fetch data (get coordinate)
UART_read(uart, &msg, 1);


// Decode data (read parameters from coordinate data)
switch(msg)
{
	case 'c':
		i = 0;
		while(i <= 13)
		{

			UART_read(uart, &msg, 1); // Read message

			// Read
		//	coord[i] = msg;

			i++;
		}


		//charToInt(coord, &xStart, &yStart, &xEnd, &yEnd, &zPos);

		// Move to start coordinate
		while((steps.x != xStart) || (steps.y != yStart))
		{
			if(steps.x < xStart)
			{
				move(POS_X);
			}
			else if (steps.x > xStart)
			{
				move(NEG_X);
			}

			if ((steps.x != xStart) && (steps.y != yStart)) // Only sleep if diagonal movement
			{
				Task_sleep(20);
				//MAP_UtilsDelay(20000);
			}

			if(steps.y < yStart)
			{
				move(POS_Y);
			}
			else if (steps.y > yStart)
			{
				move(NEG_Y);
			}
		}

		// Move from start to end coordinate
		while((steps.x != xEnd) || (steps.y != yEnd))
		{
			if(steps.x < xEnd)
			{
				move(POS_X);
			}
			else if (steps.x > xEnd)
			{
				move(NEG_X);
			}

			if ((steps.x != xEnd) && (steps.y != yEnd)) // Only sleep if diagonal movement
			{
				Task_sleep(20);
				//MAP_UtilsDelay(20000);
			}

			if(steps.y < yEnd)
			{
				move(POS_Y);
			}
			else if (steps.y > yEnd)
			{
				move(NEG_Y);
			}
		}

		break;

	case 'z':
		PWM_setDuty(pwm1, duty);

		duty = (duty + dutyInc);
		if (duty >= MAXDUTY || duty <= MINDUTY) {
			dutyInc = - dutyInc;
		}

		MAP_UtilsDelay(40000);

		break;

	case 'o':
		moveToOrigin();

		break;

	default:
		break;
}



-----------------------------------------------------------------------

PWM_Handle pwm1;
    PWM_Params params;
	/* Initiate the PWM */
    uint16_t   pwmPeriod = 20000;      // Period and duty in microseconds
    uint16_t   duty = 1000;
    uint16_t   dutyInc = 500;
    PWM_Params_init(&params);
    params.period = pwmPeriod;
    pwm1 = PWM_open(Board_PWM0, &params);
    if (pwm1 == NULL) {
    	System_abort("Board_PWM0 did not open");
    }

	
	PWM_setDuty(pwm1, duty);

---------------------------------------------------------------

void initInt()
{

	//
	// Enable Processor
	//
//	MAP_IntMasterEnable();
//	MAP_IntEnable(FAULT_SYSTICK);

//	PRCMCC3200MCUInit();
/*
	// Init interrupt for GPIO 22 - Pin 15
	unsigned int GPIO22Port = 0;
	unsigned char GPIO22Pin;
	GPIO_IF_GetPortNPin(22, &GPIO22Port, &GPIO22Pin);
	GPIOIntTypeSet(GPIO22Port,GPIO22Pin,GPIO_HIGH_LEVEL);
	GPIOIntRegister(GPIO22Port,brytarInt);
	GPIOIntClear(GPIO22Port,GPIO22Pin);
	IntPendClear(INT_GPIOA2);


	// Init interrupt for GPIO1 - Pin55
	unsigned int GPIO1Port = 0;
	unsigned char GPIO1Pin;
	//unsigned int GPIO1Int;
	GPIO_IF_GetPortNPin(1, &GPIO1Port, &GPIO1Pin);
	//GPIO1Int = GetPeripheralIntNum(GPIO1Port);
	GPIOIntTypeSet(GPIO1Port,GPIO1Pin,GPIO_HIGH_LEVEL);
	GPIOIntRegister(GPIO1Port,brytarIntYO);
	GPIOIntClear(GPIO1Port,GPIO1Pin);
	IntPendClear(INT_GPIOA0);
	IntEnable(INT_GPIOA0); // For GPIO1
	GPIOIntEnable(GPIO1Port,GPIO1Pin); // For GPIO1
*/

	/*
	// Init interrupt for GPIO23 - Pin16
	unsigned int GPIO24Port = 0;
	unsigned char GPIO24Pin;
	//unsigned int GPIO1Int;
	GPIO_IF_GetPortNPin(24, &GPIO24Port, &GPIO24Pin);
	//GPIO1Int = GetPeripheralIntNum(GPIO1Port);
	GPIOIntTypeSet(GPIO24Port,GPIO24Pin,GPIO_HIGH_LEVEL);
	GPIOIntRegister(GPIO24Port,brytarIntYO);
	GPIOIntClear(GPIO24Port,GPIO24Pin);
	IntPendClear(INT_GPIOA3);
	IntEnable(INT_GPIOA3); // For GPIO24
	GPIOIntEnable(GPIO24Port,GPIO24Pin); // For GPIO24
*/
	//IntEnable(INT_GPIOA2); // For GPIO22 & GPIO23
	//GPIOIntEnable(GPIO22Port,GPIO22Pin); // For GPIO22 & GPIO23


}